---
title: The Linux OS
description: About the Free and Open Source Linux operating system
aliases:
  - GNU/Linux
tags:
publish: true
---

# GNU/Linux Operating System


## Learning Roadmap

- **[Introduction to Linux](/Troves/Expeditions/Science%20and%20Engineering/Operating%20Systems/Linux/01%20Introduction%20to%20Linux)**
	- [History and Evolution of Linux](/Troves/Expeditions/Science%20and%20Engineering/Operating%20Systems/Linux/01%20Introduction%20to%20Linux#History%20and%20Evolution%20of%20Linux) - Provides an overview of how Linux originated and evolved over time.
	- [Understanding what Linux is](/Troves/Expeditions/Science%20and%20Engineering/Operating%20Systems/Linux/01%20Introduction%20to%20Linux#Understanding%20what%20Linux%20is) - Explains the basic principles and components of the Linux operating system.
	- [Why Use Linux?](/Troves/Expeditions/Science%20and%20Engineering/Operating%20Systems/Linux/01%20Introduction%20to%20Linux#Why%20Use%20Linux?) - Highlights the advantages of using Linux compared to other operating systems.
	- [Who uses Linux?](/Troves/Expeditions/Science%20and%20Engineering/Operating%20Systems/Linux/01%20Introduction%20to%20Linux#Who%20uses%20Linux?) - Showcases the wide range of devices that Linux can run on and the use cases it serves.
	- [How is Linux Different from other Operating Systems](/Troves/Expeditions/Science%20and%20Engineering/Operating%20Systems/Linux/01%20Introduction%20to%20Linux#How%20is%20Linux%20Different%20from%20other%20Operating%20Systems) - Discusses the fundamental differences between Linux and other popular operating systems.
	- [Linux and the Open Source Philosophy](/Troves/Expeditions/Science%20and%20Engineering/Operating%20Systems/Linux/01%20Introduction%20to%20Linux#Linux%20and%20the%20Open%20Source%20Philosophy) - Dives into the world of open source and its contributions to Linux.
- **[Getting Started with Linux](/Troves/Expeditions/Science%20and%20Engineering/Operating%20Systems/Linux/02%20Getting%20Started%20with%20Linux)**
	- [Installing Linux - A Step-by-Step Guide](/Troves/Expeditions/Science%20and%20Engineering/Operating%20Systems/Linux/02%20Getting%20Started%20with%20Linux#Installing%20Linux%20-%20A%20Step-by-Step%20Guide) - Walks through the process of installing Linux on a system, including considerations for different hardware architectures and boot methods.
	- [Understanding Linux Filesystem Hierarchy](/Troves/Expeditions/Science%20and%20Engineering/Operating%20Systems/Linux/02%20Getting%20Started%20with%20Linux#Understanding%20Linux%20Filesystem%20Hierarchy) - Provides an overview of the directory structure used in Linux and the purpose of each directory.
	- [Navigating the Command Line Interface](/Troves/Expeditions/Science%20and%20Engineering/Operating%20Systems/Linux/02%20Getting%20Started%20with%20Linux#Navigating%20the%20Command%20Line%20Interface) - Introduces basic command-line navigation and manipulation techniques.
	- [Basic Linux Commands and Utilities](/Troves/Expeditions/Science%20and%20Engineering/Operating%20Systems/Linux/02%20Getting%20Started%20with%20Linux#Basic%20Linux%20Commands%20and%20Utilities) - Covers essential commands and utilities for performing common tasks in the Linux terminal.
	- [Managing Users and Permissions](/Troves/Expeditions/Science%20and%20Engineering/Operating%20Systems/Linux/02%20Getting%20Started%20with%20Linux#Managing%20Users%20and%20Permissions) - Explains how to create and manage user accounts and set permissions for files and directories.
- [Working with Different Linux Distributions](/Working%20with%20Different%20Linux%20Distributions)
	- [Linux comes in Distributions](/Linux%20comes%20in%20Distributions) - Discusses about Linux Distributions, they why and the purpose for such an approach. 
	- [Overview of Popular Linux Distributions](/Overview%20of%20Popular%20Linux%20Distributions) - Provides an overview of popular Linux distributions, including their characteristics and use cases.
	- [Understanding the Major Families of Distros](/Understanding%20the%20Major%20Families%20of%20Distros) - Discusses the differences between major families of Linux distributions, such as Debian-based and Red Hat-based distributions.
	- [Choosing the Right Distribution for Your Needs](/Choosing%20the%20Right%20Distribution%20for%20Your%20Needs) - Offers guidance on selecting the most suitable Linux distribution based on specific requirements and preferences.
	- [Installing and Configuring Specific Distributions](/Installing%20and%20Configuring%20Specific%20Distributions) - Provides detailed instructions for installing and configuring specific Linux distributions, including customization options and post-installation tasks.
- [Linux System Administration Basics](/Linux%20System%20Administration%20Basics)
	- [Understanding the Boot Process](/Understanding%20the%20Boot%20Process) - Explains the stages involved in booting a Linux system, from BIOS/UEFI initialization to kernel loading and initialization.
	- [Managing Processes and Services](/Managing%20Processes%20and%20Services) - Covers techniques for managing running processes and system services, including using `systemd`.
	- [Managing Filesystems and Storage](/Managing%20Filesystems%20and%20Storage) - Explores advanced topics related to managing disk partitions, filesystems, and storage devices.
	- [Monitoring System Performance](/Monitoring%20System%20Performance) - Introduces tools and techniques for monitoring system performance and resource usage.
	- [Configuring Networking and Connectivity](/Configuring%20Networking%20and%20Connectivity) - Provides an overview of configuring network interfaces, IP addressing, and basic network services.
	- [Introduction to Package Management](/Introduction%20to%20Package%20Management) - Explains package management concepts and demonstrates how to install, update, and remove software packages using package managers.
	- [Handling System Updates and Upgrades](/Handling%20System%20Updates%20and%20Upgrades) - Discusses best practices for keeping Linux systems up-to-date and secure through regular updates and upgrades.
- [Scripting and Automation in Linux](/Scripting%20and%20Automation%20in%20Linux)
	- [Introduction to Scripting](/Introduction%20to%20Scripting) - Covers the basics of scripting languages used in Linux administration, focusing on Bash scripting.
	- [Scripting Fundamentals](/Scripting%20Fundamentals) - Introduces fundamental concepts of scripting, including variables, loops, conditional statements, and functions.
	- [Advanced Scripting Techniques](/Advanced%20Scripting%20Techniques) - Explores advanced scripting techniques such as error handling, input/output redirection, and regular expressions.
	- [Automating System Administration Tasks](/Automating%20System%20Administration%20Tasks) - Demonstrates how to automate common system administration tasks using shell scripts, including file management, user management, and system monitoring.
	- [Using Configuration Management Tools](/Using%20Configuration%20Management%20Tools) - Introduces configuration management tools like Ansible and Puppet for automating infrastructure provisioning, configuration, and management.
	- [Integrating Scripts with Cron and Systemd Timers](/Integrating%20Scripts%20with%20Cron%20and%20Systemd%20Timers) - Explains how to schedule and automate script execution using `cron` jobs and `systemd` timers.
- [Remotely Accessing Remote Machines](/Remotely%20Accessing%20Remote%20Machines)
	- [Accessing Linux Machines via SSH](/Accessing%20Linux%20Machines%20via%20SSH) - Explains how to remotely access Linux systems using the SSH protocol, including key-based authentication and advanced SSH configurations.
	- [Accessing Linux Instances via GUI and Remote Desktop](/Accessing%20Linux%20Instances%20via%20GUI%20and%20Remote%20Desktop) - Demonstrates how to access Linux desktop environments remotely using graphical user interfaces and remote desktop protocols.
	- [Customizing the Prompt and Shell Environment](/Customizing%20the%20Prompt%20and%20Shell%20Environment) - Shows how to customize the command prompt and shell environment to improve productivity and user experience.
	- [Using TMUX for Efficient Remote Access](/Using%20TMUX%20for%20Efficient%20Remote%20Access) - Introduces TMUX, a terminal multiplexer, and demonstrates how to use it for efficient remote access and session management.
- [Data Management and Disaster Recovery in Linux](/Data%20Management%20and%20Disaster%20Recovery%20in%20Linux)
	- **[Understanding Disaster Recovery](/Understanding%20Disaster%20Recovery)** - Discusses the importance of disaster recovery planning and strategies for minimizing downtime and data loss in the event of system failures or disasters.
	- **[Data Archival and Compression](/Data%20Archival%20and%20Compression)** - Explains the concepts of data archival and compression and demonstrates how to use tools like `tar`, `gzip`, and `zip` to archive and compress files and directories.
	- **[Creating Backup Strategies](/Creating%20Backup%20Strategies)** - Explores various backup strategies, including full, incremental, and differential backups, and discusses factors to consider when designing backup solutions.
	- **[Implementing Backup Solutions](/Implementing%20Backup%20Solutions)** - Provides guidance on selecting and implementing backup solutions, including open-source tools like `rsync`, `tar`, and proprietary backup software.
	- [Automating Backup Processes](/Automating%20Backup%20Processes) - Demonstrates how to automate backup processes using `cron` jobs, `systemd` timers, or backup software scheduling features.
	- [Managing Backup Retention](/Managing%20Backup%20Retention) - Discusses best practices for managing backup retention policies to optimize storage usage while ensuring data availability and compliance.
	- [Encryption and Security Considerations](/Encryption%20and%20Security%20Considerations) - Covers best practices for encrypting backups to protect sensitive data and ensuring backup security in transit and at rest.
- [Security and Hardening in Linux](/Security%20and%20Hardening%20in%20Linux)
	- [Securing SSH Access](/Securing%20SSH%20Access) - Provides best practices for securing SSH access to Linux systems, including disabling password authentication and implementing two-factor authentication.
	- [Implementing Firewall Rules and IP Tables](/Implementing%20Firewall%20Rules%20and%20IP%20Tables) - Demonstrates how to configure firewall rules and IP tables to control network traffic and enhance security.
	- [Setting up Intrusion Detection and Prevention Systems](/Setting%20up%20Intrusion%20Detection%20and%20Prevention%20Systems) - Introduces intrusion detection systems and demonstrates how to set up and configure them to monitor for suspicious activity.
	- [Encrypting Data and Communications](/Encrypting%20Data%20and%20Communications) - Covers encryption techniques and tools for securing data and communications on Linux systems.
	- [Best Practices for System Hardening](/Best%20Practices%20for%20System%20Hardening) - Discusses best practices for hardening Linux systems to protect against security threats and vulnerabilities.
- [Advanced Networking and Services](/Advanced%20Networking%20and%20Services)
	- **[Configuring DNS, DHCP, and LDAP Services](/Configuring%20DNS,%20DHCP,%20and%20LDAP%20Services)** - Explains how to set up and configure domain name system (DNS), dynamic host configuration protocol (DHCP), and lightweight directory access protocol (LDAP) services on Linux systems.
	- **[Setting up Web Servers](/Setting%20up%20Web%20Servers)** - Guides through the installation, configuration, and management of web servers Apache and Nginx, including virtual hosts and SSL/TLS configuration.
	- **[Managing Databases](/Managing%20Databases)** - Covers installation, configuration, and administration of relational database management systems MySQL and PostgreSQL, including database backup and replication.
	- **[Configuring Mail Servers](/Configuring%20Mail%20Servers)** - Demonstrates how to set up and configure mail servers Postfix and Sendmail for sending and receiving email, including spam filtering and mail relaying.
	- **[Setting up a Print Server](/Setting%20up%20a%20Print%20Server)** - Discusses how to set up a print server using the Common Unix Printing System (CUPS), including configuring printers, managing print queues, and enabling network printing.
	- **[Implementing VPNs and Remote Access Solutions](/Implementing%20VPNs%20and%20Remote%20Access%20Solutions)** - Introduces virtual private networks (VPNs) and remote access solutions and demonstrates how to set up and configure them on Linux systems for secure remote access.
- **[Cloud and Container Orchestration](/Cloud%20and%20Container%20Orchestration)**
	- [Introduction to Cloud Computing and Linux](/Introduction%20to%20Cloud%20Computing%20and%20Linux) - Provides an overview of cloud computing concepts and how Linux is used in cloud environments.
	- [Deploying Applications on Cloud Platforms](/Deploying%20Applications%20on%20Cloud%20Platforms) - Demonstrates how to deploy and manage applications on cloud platforms such as AWS, Azure, and Google Cloud Platform (GCP).
	- [Containerization with Docker and Kubernetes](/Containerization%20with%20Docker%20and%20Kubernetes) - Introduces containerization technologies Docker and Kubernetes and demonstrates how to build, deploy, and manage containerized applications.
	- [Managing Infrastructure as Code](/Managing%20Infrastructure%20as%20Code) - Discusses infrastructure as code (IaC) principles and tools such as Ansible and Terraform for automating infrastructure deployment and management.
	- [Integration with CI CD pipelines](/Integration%20with%20CI%20CD%20pipelines) - Explains how to integrate Linux systems with CI/CD pipelines using tools such as Jenkins and GitLab CI for automating software development processes.

## Resources and References


## Certifications


---

## Understanding Linux


### Linux OS or Linux Kernel
The term "Linux" is often used to refer to both the Linux kernel and the broader operating systems built around it, commonly known as Linux distributions. However, by definition, Linux is the kernel and there is a distinction between the Linux kernel and a complete operating system.

1. **Linux Kernel:**
    - **Definition:** The Linux kernel is the core component of the Linux operating system. It is the part of the operating system responsible for managing hardware resources, providing essential services, and facilitating communication between software and hardware components.
    - **Functionality:** The kernel handles tasks such as process scheduling, memory management, device drivers, file system access, and system calls. It acts as an intermediary layer between the hardware and the user-level software.
    - **Role:** The kernel is essential for the functioning of an operating system, but it is not sufficient on its own to provide a complete operating system experience for end-users.
2. **Complete Operating System (Linux Distributions):**
    - **Definition:** When people commonly refer to "Linux" as an operating system, they are often talking about a complete operating system that includes not only the Linux kernel but also a collection of software utilities, libraries, user interfaces, and application software. These complete systems are commonly known as Linux distributions or distros.
    - **Components:** A Linux distribution typically includes the Linux kernel, system libraries, shell utilities, system management tools, desktop environments, and application software. Distributions vary in their configurations, package management systems, and default software selections.
    - **Examples:** Ubuntu, Fedora, Debian, CentOS, and Arch Linux are examples of popular Linux distributions. Each distribution takes the Linux kernel and builds a complete, user-friendly operating system around it.

### Diving into Distros

Linux distributions, often referred to as "*distros*," are variations of the Linux operating system that include the *Linux kernel*, *system libraries*, *utilities*, and *additional software* tailored to meet specific user needs or use cases. The existence of numerous distributions reflects the diversity of preferences, requirements, and objectives within the open source community.

1. **Flexibility and Customization:** The open source nature of Linux allows users and developers to customize the operating system according to their preferences and requirements. This has led to the creation of a wide range of distributions tailored for various purposes.
2. **Specialized Use Cases:** Different users have different needs, and specialized distributions have emerged to cater to specific use cases, such as servers, desktops, embedded systems, scientific computing, multimedia production, and security.
	- **Server Deployments:** Some distributions are optimized for server environments, emphasizing stability, security, and performance. Examples include *RHEL*, *CentOS*, *Debian*, and *Ubuntu Server*.
	- **Desktop and User-Friendly Environments:** Distributions designed for desktop use focus on providing user-friendly interfaces, pre-installed applications, and a seamless user experience. Examples include *Ubuntu*, *Fedora*, and *Linux Mint*.
	- **Security and Privacy:** Certain distributions prioritize security and privacy features, often designed for use in security-conscious or privacy-focused environments. Examples include *Tails*, *Qubes OS*, and *Parrot Security*.
	- **Educational and Learning Purposes:** Distributions aimed at educational institutions and users learning about Linux and open source software provide tools and resources for experimentation and learning. Examples include *Edubuntu* and *Raspberry Pi OS*.
	- **Embedded Systems and IoT Devices:** Lightweight distributions are suitable for embedded systems and Internet of Things (IoT) devices, where resource efficiency is crucial. Examples include *OpenWrt*, *Buildroot*, and *Yocto Project*.
	- **Scientific and Research Computing:** Distributions tailored for scientific and research purposes often include specialized tools and libraries for tasks such as data analysis, simulations, and scientific computing. Examples include *Scientific Linux* and *Ubuntu Studio*.
3. **Community Collaboration:** The collaborative nature of the open source community encourages individuals and groups to create their distributions, fostering innovation and experimentation in software development.

### Commonly used Distros

Some of the most commonly used distros are listed below.

1. **Debian**
	- Debian was *founded in 1993* by *Ian Murdock*. It is known for its *commitment* to *free and open-source software principles*.
	- Its intended Audience includes general-purpose users and it is suitable for desktops, servers, and embedded systems.
	- This distro is usually used as a base for many other distributions, server environments, desktop systems.
2. **Ubuntu**
	- Ubuntu is derived from Debian and was *first released in 2004* by *Mark Shuttleworth*. It focuses on *ease of use* and *user-friendly features*.
	- The intended audience for Ubuntu are common desktop users, developers, and enterprises and finds its use in desktop computing, development, servers, cloud computing.
3. **Fedora**
	- Fedora, *sponsored by Red Hat*, was *first released in 2003*. It serves as a bleeding-edge *testing ground* for technologies that eventually make their way into Red Hat Enterprise Linux.
	- It is commonly used by developers, enthusiasts, and those interested in cutting-edge technologies for desktop computing, development, testing new technologies.
4. **Arch Linux**
	- Arch Linux, known for its simplicity and customization, was created by Judd Vinet in 2002.
	- It is commonly used by enthusiasts, power users, those who prefer minimalism and customization and those preferring rolling-release desktops and in servers and embedded systems.
5. **OpenSUSE**
	- OpenSUSE, *originally released as S.u.S.E in 1994*, is a German Linux distribution known for its *YaST configuration tool*.
	- It is used by general-purpose users, developers, and enterprises for desktop computing, development and in servers.
6. **CentOS**
	- CentOS (*Community ENTerprise Operating System*) was* a downstream, community-supported version of Red Hat Enterprise Linux.
	- It is used by enterprise users and in server environments who require a rock-solid operating system in server deployments and in enterprise applications.
7. **Linux Mint**
	- Linux Mint, based on Ubuntu, was *first released in 2006*. It emphasizes user-friendliness and simplicity.
	- Its target audience are desktop users, those transitioning from other operating systems who require a good operating system for desktop computing, multimedia with a user-friendly experience.
8. **Manjaro**
	- Manjaro, based on Arch Linux, was *first released in 2011*. It aims to provide an *Arch-based system* with an easier installation process.
	- It is predominantly used by enthusiasts, those interested in *Arch without the complexity* in desktop computing, gaming, enthusiasts.
9. **Elementary OS**
	- Elementary OS, with its Pantheon desktop environment, was *first released in 2011*. It focuses on *design* and *ease of use*.
	- It is intended for desktop users, those who appreciate a *polished and aesthetically pleasing user experience* in *desktop computing*, *design-oriented tasks*.
10. **Red Hat Enterprise Linux (RHEL)**
	- RHEL, developed by *Red Hat*, has its roots in the original Red Hat Linux distribution. It was *first released in 2000*.
	- It is intended for Enterprises, businesses, servers, cloud environments used in enterprise-level server deployments, business-critical applications, cloud computing.
11. **NixOS**
	- NixOS, *developed since 2003*, introduces a unique approach to package management with the *Nix package manager*, emphasizing declarative and reproducible system configuration.
	- Intended for system administrators and DevOps professionals interested in functional package management and declarative system configuration.
	- NixOS is used for *Infrastructure as Code (IaC)* and *development environments*, offering *atomic upgrades* and *rollbacks*.
12. **Tails**
	- *Tails* or *The Amnesic Incognito Live System*, created in 2009, prioritizes *user privacy* and *anonymity*, offering a secure, *live operating system* designed to leave no trace.
	- Intended for privacy-conscious individuals, whistleblowers, and dissidents requiring an *anonymous platform* for communication and *secure data handling*.
	- Tails is used for anonymous browsing, secure data handling, and digital forensics, with traffic routed through the *Tor network* by default.

> [!INFO] Goodbye CentOS
> Contents

### Installing Software

There are 3 most popular ways to install software packages in Linux, namely
1. **Graphical Package Managers** `(Beginner-Mode)`
	- Graphical tools similar to Apple's App Store, Google's Play Store or Microsoft's Microsoft Store are used to browse, search and install software packages on a Linux machine.
	- Different Linux distros have their own version of application store called by different names.
	- **Pros**
		- *User Friendly* - Offers a visual interface for users who are not comfortable with the command line.
		- *Browsing and Searching* - Allows users to visually explore and search for software.
	- **Cons**
		- *Limited Control* - May not provide the same level of control as command-line tools.
		- *Distribution Specific* - The tool might be specific to certain distributions.
	- The intended audience for this method includes casual users, those transitioning from other operating systems, and users who prefer a graphical interface.
	- The prominent use case for this method is desktop users who need an easy way to discover and install software
2. **Command-Line Package Managers** `(Pro-Mode)`
	- Install and manage packages using command-line tools like APT on Debian-based systems or YUM on Red Hat-based systems.
	- **Pros**
		- *Efficiency* - Ideal for remote servers and automation scripts.
		- *Granular Control* - Provides detailed control over package installation and updates.
	- **Cons**
		- *Learning Curve* - Requires familiarity with command-line syntax.
		- *Less Visual* - Lacks a graphical interface for users who prefer visual interaction.
	- This method is catered towards system administrators and power users who are comfortable with the command line.
	- This method is predominantly used in server environments where a GUI interface is typically not available.
3. **Manual Compilation and Installation** `(Chad-Mode)`
	- Download source code, compile it, and manually install the software.
	- **Pros**
		- *Maximum Control* - Provides complete control over compilation options.
		- *Custom Configurations* - Useful when specific configurations are needed.
	- **Cons**
		- *Dependency Issues* - Prone to issues related to missing dependencies.
		- *Not Beginner-Friendly* - Not suitable for users new to Linux.
	- The target audience are advanced users, developers and those people requiring advanced configurations on their software.
	- The main use case of this method includes scenarios of development and custom configurations.
4. **Containerized Formats**
	- Usually cross-distribution support with sandboxed environments and runtime bundles.
	- They support automatic updates.
	- Some of the common examples are Flatpak, AppImage and Snap (by Canonical - Company behind Ubuntu)
	- **Pros**
		- *Cross-distribution support* - Can run across most Linux distributions
		- *Sandboxing* - Apps are packaged with their dependencies and a runtime, similar to a [Docker](../../../Infrastructure-&-Ops/Platforms/Docker/index.md) container
		- *Automatic Updates* - Hassle free auto updates for the software package
	- **Cons**
		- *Larger File Sizes* - Due to containerized formats with the dependencies and runtime, the packages tend to be larger in size.
	- This method is aimed at users who want a cross distribution compatible app with automatic updates and a containerized runtime environment.
	- Their main use case is running apps without installation.


Linux offers a multitude of options for the following reasons
1. **Flexibility** - Different users have different preferences and levels of expertise. Offering multiple methods caters to a broad audience.
2. **Use Case Scenarios** - Command-line tools are efficient for servers and automation, while graphical tools are more accessible for desktop users.
3. **Distribution Variety** - Linux distributions have different package formats and management tools. Offering flexibility accommodates these variations.
4. **Legacy and Tradition** - Manual compilation has been a traditional way to install software on Unix/Linux systems. While less common now, it's still an option for those who prefer it.

Installing software packages via a package manager is one of the most common and prevalent ways to install, manage, maintain and uninstall software packages in Linux. *Package management* is a system used in Linux to simplify the process of *installing*, *updating*, *configuring*, and *removing* software packages on a computer. A package is a *compressed archive* containing *executable programs*, *libraries*, *documentation*, and *configuration files* required for a specific piece of software.

Following are the significance of maintaining software installations via a package management system.
1. **Simplified Installation** - Package managers *automate the installation process*, handling dependencies and ensuring that all required files are placed in the correct locations.
2. **Dependency Resolution** - Package managers *track dependencies*, ensuring that when you install a new piece of software, any required libraries or components are also installed.
3. **Consistent Updates** - Package managers provide a *unified way to update software*. Users can easily keep their system and applications up-to-date with the latest security patches and features.
4. **Centralized Management** - Package management centralizes software installation and maintenance. It simplifies tasks for system administrators and users by offering a standardized approach.

The following table serves as a reference for the most commonly used distros along with the package management in them

| Linux Distribution | Package Manager       | Command-Line Package Manager | GUI Installer            | Containerized Installers |
|--------------------|-----------------------|------------------------------|--------------------------|--------------------------|
| **Debian/Ubuntu**      | APT                   | APT                          | Synaptic, GNOME Software | Snap, Flatpak, AppImage  |
| **Red Hat/Fedora**     | DNF, YUM              | DNF, YUM                     | GNOME Software           | Snap, Flatpak, AppImage  |
| **Arch Linux**         | Pacman                | Pacman                       | Octopi, Pamac            | Snap, Flatpak, AppImage  |
| **openSUSE**           | Zypper                | Zypper                       | YaST Software Manager    | Snap, Flatpak, AppImage  |
| **Lubuntu**            | APT, Snap, Flatpak    | APT                          | Discover                 | Snap, Flatpak, AppImage  |
| **Ubuntu (Default)**   | APT, Snap, Flatpak    | APT                          | Ubuntu Software Center   | Snap, Flatpak, AppImage  |
| **Deepin**             | DPKG, APT, Flatpak    | DPKG, APT                    | Deepin Software Center   | Flatpak, AppImage        |
| **Fedora Workstation** | DNF, Flatpak          | DNF                          | GNOME Software           | Flatpak, AppImage        |
| **Manjaro**            | Pacman, Snap, Flatpak | Pacman                       | Octopi, Pamac            | Snap, Flatpak, AppImage  |
| **elementary OS**      | DPKG, APT             | DPKG, APT                    | AppCenter                | Flatpak, AppImage        |

---
## The Linux CLI

### Fundamentals

The *Command-Line Interface* or *CLI* is a text-based interface that allows users to interact with a computer by typing commands. In Linux, the CLI is commonly accessed through a terminal emulator, providing a direct means to issue commands to the operating system.

| Terminal | Console | Shell |
| ---- | ---- | ---- |
| A terminal is the software interface that allows users to *interact with the CLI*. It provides a *text-based* environment for entering commands and receiving text-based output. | The console typically refers to the *physical* *terminal* or the terminal window in which the CLI is accessed. | The shell is a *command interpreter* that interprets and *executes user commands*. It acts as an *interface between the user and the kernel*, translating *commands into system actions*. |
| Terminal emulators, such as *GNOME Terminal*, *Konsole*, and *xterm*, are applications that serve as *graphical interfaces to the CLI*. | In Linux, it can also refer to a virtual console accessed using key combinations (e.g., Ctrl+Alt+F1) that provides a *text-only interface*. | Popular shells include *Bash* (Bourne Again SHell), *Zsh* (Z Shell), and *Fish*. Users can choose the shell they prefer, and each shell has its own features and scripting capabilities. |

Following are the most commonly used shells in Linux

1. **Bash (Bourne Again SHell)**    
    - Bash is the default shell for many Linux distributions and macOS. It is an enhanced version of the original Bourne Shell (sh) and provides extensive features for interactive use and scripting.
    - It is widely used in system administration and as the default interactive shell for users.
    - Some of its features include
        - Command history and auto-completion.
        - Job control and background processing.
        - Shell scripting with support for conditional statements, loops, and functions.
2. **Zsh (Z Shell)**
    - Zsh is known for its user-friendly enhancements over Bash. It includes advanced features for interactive use and scripting and is designed to be more customizable.
    - It is popular among power users who appreciate its interactive features and enhanced scripting.
    - Some of its features include
        - Advanced tab completion with context-aware suggestions.
        - Theming and extensive customization options.
        - Improved scripting capabilities and associative arrays.
3. **Fish (Friendly Interactive SHell)**    
    - Fish is designed to be user-friendly and interactive. It features syntax highlighting, auto-suggestions, and a clean command-line interface.
    - It is suited for users who prioritize a friendly and intuitive command-line experience.
    - Some of its features include
        - Auto-suggestions based on command history.
        - Syntax highlighting for commands and errors.
        - Web-based configuration interface.
4. **Dash:**
    - Dash is a lightweight POSIX-compliant shell designed for efficiency. It aims to be faster than Bash and is often used in system scripts where speed is crucial.
    - It is frequently used in Debian-based systems for system scripts and as /bin/sh.
    - Some of its features include
        - Minimalistic design with focus on speed and simplicity.
        - POSIX-compliant scripting capabilities.
        - Suitable for non-interactive use and system scripts.
5. **Tcsh (Tenex C Shell)**
    - Tcsh is an enhanced version of the C shell (csh) with additional features for interactive use. It includes features like command-line editing and history.
    - It was historically used in interactive environments and by users familiar with C shell features.
    - Some of its features include
        - Command-line editing and history with arrow key support.
        - Spelling correction and directory stack management.
        - Customizable prompts and aliases.

The following table summarizes some of the most commonly found *Terminal Emulators* in the most commonly used distros.

| Terminal Emulator | Desktop Environment | Prevalent Distributions     |
|-------------------|---------------------|-----------------------------|
| **GNOME Terminal**    | GNOME               | Ubuntu, Fedora, Debian      |
| **Konsole**           | KDE Plasma          | Kubuntu, openSUSE, KDE neon |
| **xfce4-terminal**    | Xfce                | Xubuntu, Manjaro Xfce       |
| **Alacritty**         | Independent         | Arch Linux, Manjaro         |
| **xterm**             | Independent         | Various, included in many   |
| **Terminator**        | Independent         | Ubuntu, Fedora, Arch Linux  |
| **Tilix**             | Independent         | Fedora, Ubuntu, Arch Linux  |
| **Kitty**             | Independent         | Arch Linux, Manjaro, Fedora |
| **Yakuake**           | KDE Plasma          | Kubuntu, openSUSE           |

### Commonly used Commands

#### Help Commands
- `man` - Display the manual for a command
- `--help` or `-h` or `help` - Display help information for a command
- `whatis` - Display one-line manual page descriptions
- `info` - View information about a command

#### File System Commands
- `ls` - List directory contents
- `cp` - Copy files or directories
- `mv` - Move or rename files or directories
- `rm` - Remove files or directories
- `mkdir` - Create a new directory
- `rmdir` - Remove an empty directory
- `chmod` - Change file permissions
- `chown` - Change file owner and group
- `df` - Display free disk space
- `du` - Show directory space usage

#### Text Processing Commands
- `cat` - Concatenate and display file content
- `grep` - Search for a pattern in files
- `sed` - Stream editor for filtering and transforming text
- `awk` - Pattern scanning and processing language

#### System Information Commands
- `top` - Display and update sorted information about system processes
- `ps` - Display information about active processes
- `htop` - Interactive process viewer
- `free` - Display amount of free and used memory in the system
- `uptime` - Show how long the system has been running

#### Networking Commands
- `ifconfig` - Configure and display network interfaces
- `ip` - Show or manipulate routing, devices, policy routing, and tunnels
- `ping` - Send ICMP Echo Request to network hosts
- `netstat` - Display network connections, routing tables, interface statistics, masquerade connections, and multicast memberships
- `ss` - Another utility to investigate sockets
- `ssh` - OpenSSH SSH client (connect to a remote server)

#### User Management Commands
- `useradd` - Create a new user account
- `userdel` - Delete a user account
- `passwd` - Change user password
- `su` - Switch user
- `sudo` - Execute a command as another user

#### Process Management Commands
- `kill` - Terminate processes by PID or name
- `pkill` - Signal processes based on their name
- `killall` - Kill processes by name
- `nohup` - Run a command immune to hangups
- `bg` / `fg` - Put a process in the background / bring a process to the foreground

#### System Administration Commands
- `systemctl` - Control the systemd system and service manager
- `journalctl` - Query and display messages from the journal
- `journalctl -xe` - Display all messages, including ones from earlier boots
- `systemd-analyze` - Analyze and debug system boot-up performance
- `crontab` - Schedule tasks to run at fixed times

#### System Monitoring Commands
- `sar` - Collect, report, or save system activity information
- `vmstat` - Report virtual memory statistics
- `iostat` - Report CPU, disk I/O, and NFS statistics
- `nmon` - Performance monitoring tool for Linux
- `dstat` - Versatile resource statistics tool
- `uptime` - Show how long the system has been running

#### System Information Commands
- `uname` - Print system information
- `lsb_release` - Display Linux distribution-specific information
- `hostname` - Show or set the system's host name
- `lshw` - List hardware information
- `lscpu` - Display information about the CPU architecture
- `lsblk` - List block devices
- `fdisk` - Partition table manipulator for Linux
- `mount` - Mount a filesystem
- `umount` - Unmount a filesystem



---



## dsdsd
---

```sh
# Getting help from the man pages
man chmod

# Getting help from info
info chmod

# Using the less command
man chmod | less

# getting help from the help flag
command -h 
command --help
```

### Basic Commands
Basic commands in the context of the Linux terminal refer to essential and frequently used commands that allow users to navigate the file system, perform file operations, work with text, obtain system information, and manage user permissions. These commands form the foundation for interacting with the operating system efficiently.

#### Navigating the File System

##### `cd`

The `cd` or _change directory_ command is used to navigate the filesystem by moving from one directory to another. It is a fundamental command for working with the terminal. Below is the general syntax and common usage examples of the `cd` command

```sh
# General Syntax
cd [directory_path]

# Basic Usage:
cd Documents

# Navigate to Home Directory:
cd ~

# Move Up One Directory Level:
cd ..

# Move to the Root Directory:
cd /

# Move to the Previous Directory:
cd -

# Use Absolute Path:
cd /path/to/directory

# Use Relative Path:
cd ../relative/directory

```

##### `ls`

The `ls` command, short for _list_, is used to display the contents of a directory. It provides information about files and directories within the specified location. Below is the general syntax and common usage examples of the `ls` command

```sh

# General Syntax
ls [options] [directory_path]

# Basic Usage:
ls

# List Files and Directories in a Specific Directory:
ls Documents

# Long Format Listing:
ls -l

# List All Files, Including Hidden Ones:
ls -a

# Long Format with Human-Readable File Sizes:
ls -lh

# Recursively List Subdirectories:
ls -R

# Sort by Modification Time (Newest First):
ls -lt

# Sort by Size (Largest First):
ls -S

```

##### `pwd`

The `pwd` or _print working directory_ command is used to display the current working directory. It provides the full path of the directory you are currently in. Below is the general syntax and common usage example of the `pwd` command

```sh
# General Syntax
pwd

# Display the current working directory
pwd

```

##### `mkdir`

The `mkdir` or _make directories_ command is used to create new directory or directories with the specified name(s). Below is the general syntax and the most common usage examples of the command:

```sh
# General Syntax
mkdir [options] [directory/directories]

# Basic Usage:
mkdir Documents

# Create Parent Directories:
mkdir -p Projects/Python/Scripts

# Set Permissions (like chmod):
# Here, 755 grants read, write, and execute permissions to the owner,
# and read and execute permissions to group and others.
mkdir -m 755 Public

# Create Multiple Directories:
mkdir dir1 dir2 dir3
# Example:
mkdir Documents Pictures Music

# Verbose Mode:
# -v option shows each directory as it is created.
mkdir -v Downloads

# Interactive Mode:
# -i option prompts for confirmation before creating each directory.
mkdir -i Temp

```

##### `rmdir`

The `rmdir` or *remove directory* command is used to remove empty directories in the Linux terminal. It is specifically designed to delete directories that do not contain any files or subdirectories. Below is the general syntax and common usage examples of the `rmdir` command.

```sh
# General Syntax
rmdir [options] [directory/directories]

# Basic Usage:
rmdir EmptyDir

# Remove Multiple Empty Directories:
rmdir Dir1 Dir2 Dir3

# Remove Empty Directory with Absolute Path:
rmdir /path/to/directory

# Remove Empty Directory with Relative Path:
rmdir ../relative/directory

# Options/Flags:
# -p, --parents: Remove DIRECTORY and its ancestors.
# Example:
rmdir -p /a/b/c

```

##### `rm`

The `rm` or _remove_ command is used to delete files or directories in the Linux terminal. It is a powerful command that can be used with various options for different purposes. Below is the general syntax and common usage examples of the `rm` command.

```sh
# General Syntax for Removing Files
rm [options] [file/files]

# Basic Usage for Removing a File:
rm unwanted_file.txt

# Remove Multiple Files:
rm file1.txt file2.txt file3.txt

# Options/Flags:
# Remove a Directory and Its Contents Recursively:
rm -r directory_to_remove

# -i, --interactive: Prompt before every removal.
# Example:
rm -i sensitive_file.txt

# -f, --force: Ignore nonexistent files and do not prompt.
# Example:
rm -f file_to_delete

```

#### File Operations

##### `cp`

The `cp` or _copy_ command is used to copy files or directories in the Linux terminal. It allows duplicating files and directories with various options for different use cases. Below is the general syntax and common usage examples of the `cp` command.

```sh
# General Syntax
cp [options] [source] [destination]

# Basic Usage for Copying a File:
cp file.txt backup/

# Copy Multiple Files to a Directory:
cp file1.txt file2.txt directory/

# Recursively Copy Directory and Its Contents:
cp -r source_directory/ destination/

# Options/Flags:
# -i, --interactive: Prompt before overwriting files.
# Example:
cp -i important_file.txt backup/

# -r, -R, --recursive: Copy directories and their contents recursively.
# Example:
cp -r source_directory/ destination/

# -u, --update: Copy only when the source file is newer than the destination file.
# Example:
cp -u updated_file.txt backup/

```

##### `mv`

The `mv` or _move_ command is used to *move* or *rename files* and directories in the Linux terminal. It is a versatile command that can be used for various operations related to file and directory manipulation. Below is the general syntax and common usage examples of the `mv` command.

```sh
# General Syntax for Moving/Renaming
mv [options] [source] [destination]

# Basic Usage for Moving a File:
mv file.txt new_location/

# Move and Rename a File:
mv old_name.txt new_name.txt

# Move a Directory and Its Contents:
mv source_directory/ destination/

# Options/Flags:
# -i, --interactive: Prompt before overwriting files.
# Example:
mv -i existing_file.txt new_location/

# -u, --update: Move only when the source file is newer than the destination file or when the destination file is missing.
# Example:
mv -u updated_file.txt backup/

```

##### `touch`

The `touch` command is used to *create empty files* or *update the timestamp of existing files* in the Linux terminal. It is a simple command with various applications, including file creation and updating file timestamps. Below is the general syntax and common usage examples of the `touch` command.

```sh
# General Syntax
touch [options] [file/files]

# Basic Usage for Creating an Empty File:
touch new_file.txt

# Update Timestamp of an Existing File:
touch existing_file.txt

# Create Multiple Empty Files:
touch file1.txt file2.txt file3.txt

# Options/Flags:
# -c, --no-create: Do not create new files.
# Example:
touch -c existing_file.txt

# -t, --date=STRING: Use the specified date and time instead of the current time.
# Example:
touch -t 202201011200 updated_file.txt

```

#### Working with Text

##### `cat`

The `cat` or _concatenate_ command is used to display the content of files in the Linux terminal. It is a versatile command that can be used for various text-related operations. Below is the general syntax and common usage examples of the `cat` command.

```sh
# General Syntax
cat [options] [file/files]

# Basic Usage:
cat document.txt

# Display Content of Multiple Files:
cat file1.txt file2.txt

# Concatenate and Display Content:
cat file1.txt file2.txt > combined_file.txt

# Options/Flags:
# -n, --number: Number all output lines.
# Example:
cat -n document.txt

# -A, --show-all: Equivalent to -vET.
# Example:
cat -A document.txt

# -E, --show-ends: Display $ at end of each line.
# Example:
cat -E document.txt

```

##### `echo`

The `echo` command is used to display text or write text to a file in the Linux terminal. It is a simple yet powerful command commonly used in shell scripting. Below is the general syntax and common usage examples of the `echo` command.

```sh
# General Syntax
echo [options] [text]

# Basic Usage:
echo "Hello, World!"

# Display Variable:
greeting="Welcome to Linux"
echo $greeting

# Write Text to a File:
echo "This is some text" > output.txt

# Options/Flags:
# -e: Enable interpretation of backslash escapes.
# Example:
echo -e "Line 1\nLine 2\nLine 3"

# -n: Do not output the trailing newline.
# Example:
echo -n "A line of text"
echo "This also prints on the same line"

```

#### System Information

##### `uname`

The `uname` or _Unix Name_ command is used to print system information in the Linux terminal. It provides details about the system's kernel and other system-related information. Below is the general syntax and common usage examples of the `uname` command.

```sh
# General Syntax
uname [options]

# Basic Usage to Print System Information:
uname

# Display the Kernel Name:
uname -s

# Display the Network Node Hostname:
uname -n

# Display the Kernel Release:
uname -r

# Display the Kernel Version:
uname -v

# Display the Machine Hardware Name:
uname -m

# Display the Processor Type:
uname -p

# Display the Operating System:
uname -o

```

##### `df`

The `df` or _disk free_ command is used to display information about disk space usage on Linux systems. It provides details about the available and used disk space on mounted filesystems. Below is the general syntax and common usage examples of the `df` command.

```sh
# General Syntax
df [options] [file/files]

# Basic Usage to Display Disk Space Usage:
df

# Display Disk Space Usage in Human-Readable Format:
df -h

# Display Disk Space Usage for a Specific Filesystem:
df /dev/sda1

# Display Disk Space Usage for All Filesystems:
df -a

# Print the type of filesystem:
df -T

# Options/Flags:
# -h, --human-readable: Print sizes in human-readable format (e.g., KB, MB, GB).
# -T, --print-type: Print file system type.
# -a, --all: Include pseudo, duplicate, inaccessible file systems.

```
##### `free`

The `free` command is used to display information about system memory usage on Linux. It provides details about the total, used, and free memory, as well as swap space. Below is the general syntax and common usage examples of the `free` command.

```sh
# General Syntax
free [options]

# Basic Usage to Display Memory Usage:
free

# Display Memory Usage in Human-Readable Format:
free -h

# Display Memory Usage with Total and Individual Columns:
free -t

# Display Memory Usage in Continuous Refresh Mode:
free -s 2

# Options/Flags:
# -h, --human-readable: Print sizes in human-readable format (e.g., KB, MB, GB).
# -t, --total: Display a line with the totals.
# -s, --seconds N: Continuously display updated statistics every N seconds.

```

#### Users and Permission

##### `whoami`

The `whoami` command is used to print the username associated with the current effective user ID in the Linux terminal. It provides a quick way to identify the user executing the command. Below is the general syntax and common usage examples of the `whoami` command.

```sh
# General Syntax
whoami

# Basic Usage to Display Current User:
whoami

```
##### `chmod`

The `chmod` command in Linux is used to change the permissions of a file or directory. It allows providing permissions to users to who can read, write, and execute the file. 

```sh
# General syntax
chmod [options] [permissions] file

```

- Permissions are a way to control access to files and directories. 
- There are three primary permissions
	- `READ`
		- *For Files* - Enables reading the content of the file.
		- *For Directories* - Enables listing the contents of the directory.
	- `WRITE`
		- *For Files* - Enables modifying, appending, or truncating the content of the file.
		- *For Directories* - Enables creating, deleting, or renaming files within the directory.
	- `EXECUTE`
		- *For Files* - Enables executing the file if it is a script or executable.
		- *For Directories* - Enables entering (accessing) the directory.
- Permissions can be assigned to three categories of users
	- `OWNER` - The user who owns the file or directory.
	- `GROUP` - Users who are members of the group associated with the file or directory.
	- `OTHERS` - Users who are neither the owner nor in the group.

The `chmod` command can be applied via two types of notations, namely 
- Numeric notation (octal notation)
- Symbolic notation (letter notation)

**Numeric Notation or Octal Notation**
- In numeric notation, permissions are represented by a three-digit octal number.
- Each digit corresponds to the permission set for a specific user category in the order `OWNER`, `GROUP`, and `OTHERS`.
- The level of permission is denoted by a numerical system with `READ`, `WRITE` and `EXECUTE` privileges assigned as below 
	- `(4) READ (r)` 
	- `(2) WRITE (w)` 
	- `(1) EXECUTE (x)`
- The permission levels can be stringed together by adding the numerical values as follows
	- `(0) NO PERMISSION`
	- `(1) EXECUTE ONLY`
	- `(2) WRITE ONLY`
	- `(3) WRITE AND EXECUTE`
	- `(4) EXECUTE ONLY`
	- `(5) READ AND EXECUTE`
	- `(6) READ AND WRITE`
	- `(7) READ, WRITE & EXECUTE`

```sh
# Basic usage for chmod with numeric notation
# Grants READ, WRITE and EXECUTE Permissions to OWNER, GROUP and OTHERS
chmod 777 program.sh 

# No permissions for OWNER, GROUP, and OTHERS
chmod 000 program.sh

# EXECUTE permission to OWNER ONLY
chmod 100 program.sh

# WRITE permission to OWNER
chmod 200 program.sh

# WRITE & EXECUTE permission to OWNER
chmod 300 program.sh

# READ permission to OWNER ONLY
chmod 400 program.sh

# READ & EXECUTE permission to OWNER
chmod 500 program.sh

# READ & WRITE permission to OWNER
chmod 600 program.sh

# READ, WRITE, and EXECUTE permission to OWNER
chmod 700 program.sh

# Similarly, if the numeric value is assigned
# in the middle number (ex: 010), then the GROUP
# permissions are set and then the final digit 
# (ex: 001) corresponds to the OTHERS

```




```sh
# Common Options
# -c, --changes: Verbosely describe the action for each file processed.
# -f, --silent, --quiet: Suppress most error messages.
# -v, --verbose: Output a diagnostic for every file processed.
# --reference: Use the same permissions as the reference_file.
# --version: Display the version information and exit.

# verbosely describes the action for each file
chmod -c u+x file.txt
chmod -c 100 file.txt
```

##### `chown`



### Advanced Commands



#### Pipelines and Redirects
- `|` (pipe): Redirect output of one command to another.
- `>` and `<`: Redirect output to and from files.
- `>>`: Append output to a file.

#### Wildcards & Expansions
- `*`: Match any characters in filenames.
- `?`: Match any single character.
- `[]`: Match any one of the enclosed characters.

#### Searching & Filtering
- `grep`: Search for patterns in files.
- `find`: Search for files and directories.
- `awk` and `sed`: Text processing tools.

#### Process Management
- `ps`: Display information about active processes.
- `kill`: Terminate processes.
- `top` or `htop`: Display real-time system statistics.

### Shell Scripting

#### Environment Variables


#### Conditionals and Loops
`if`, `else`, `elif`, `for`, `while`: Conditional and looping constructs.

### Essential Tools 

#### Package Management
- `apt`, `yum`, `dnf`, `pacman`: Package management commands.
- Installing and removing software packages.

#### Text Editors
vi and nano

#### Networking Tools
- `ping`, `traceroute`, `netstat`, `ifconfig`: Basic networking commands.
- `ssh`: Secure Shell for remote access.

### Troubleshooting and Logs

#### Viewing Logs
- `tail`, `head`, `less`: View contents of log files.
- `/var/log/` directory: Common log file locations.

#### Troubleshooting
- `dmesg`, `journalctl`: Display system messages.
- `lsof`: List open files and processes.

